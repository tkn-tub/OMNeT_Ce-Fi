[General]
sim-time-limit = 30s
repeat = 20 

# To reduce the amount of data gathered, the statistic-recording is heavily limited
**.statistic-recording = false
**.param-recording = false


[Config GreenField]
network = adHocNetwork
description = "Setting up the overall settings"
**.arp.typename = "GlobalArp" 

# Number of Stations
**.nSta = ${N = 1, 3, 5, 6, 10} 

# MOBILITY
**.constraintAreaMinX = 0m
**.constraintAreaMinY = 0m
**.constraintAreaMinZ = 0m
**.constraintAreaMaxX = 15m
**.constraintAreaMaxY = 15m
**.constraintAreaMaxZ = 0m

**.sta[0].mobility.typename = "StationaryMobility"
**.sta[0].mobility.initialX = 4m
**.sta[0].mobility.initialY = 3m

**.adHocAp.mobility.typename = "StationaryMobility"
**.adHocAp.mobility.initialX = 3m
**.adHocAp.mobility.initialY = 4m


# APPLICATION
**adHocAp.numApps 	= 2
**sta[0].numApps 	= 2
**sta[1..].numApps 	= 1



# Receiver for station transmissions
**.adHocAp.app[0].typename 		= "UdpSink"
**.adHocAp.app[0].localPort 	= 1000
# Transmitter to stations
**.adHocAp.app[1].typename 		= "UdpBasicApp"
**.adHocAp.app[1].destPort 		= 1001
**.adHocAp.app[1].destAddresses = "sta[0]"


# Unicast to AP
**.sta[*].app[0].typename 		= "UdpBasicApp"
**.sta[*].app[0].destPort 		= 1000
**.sta[*].app[0].destAddresses 	= "adHocAp" 
# Add UDP Sink to the first station
**.sta[0].app[1].typename 		= "UdpSink"
**.sta[0].app[1].localPort 		= 1001
**.messageLength = ${messageLength = 8000B}


# SendIntervals
# FH-delay vs TP
**.sta[0].app[0].sendInterval 	= exponential(${ulInterval = 500us})#
**.sta[1..].app[0].sendInterval = exponential(${ulInterval})  
**.adHocAp.app[1].sendInterval 	= exponential(${dlInterval= 500us}) 


## UL vs TP
#**.sta[0].app[0].sendInterval 	= exponential(${ulInterval = 500us, 1000us, 1500us, 2500us, 3500us, 5000us, 8000us, 10000us, 12000us, 16000us, 20000us, 32000us, 64000us, 128000us, 256000us,  1024000us})#
#**.sta[1..].app[0].sendInterval = exponential(${ulInterval})
#**.adHocAp.app[1].sendInterval 	= exponential(${dlInterval= 500us}) # Effectively Full Buffer

## DL vs NDF
#**.sta[0].app[0].sendInterval 	= ${ulInterval = 60000000 us} # Effectively no UL
#**.sta[1..].app[0].sendInterval = ${ulInterval}
#**.adHocAp.app[1].sendInterval 	= exponential(${dlInterval=300us, 600us, 1000us, 1500us,2000us, 3000us, 4000us, 5000us, 10000us,  30000us,  100000us, 300000us, 1000000us })

## UDP vs TCP NDF
#**.sta[0].app[0].sendInterval 	= ${ulInterval = 60000000 us}
#**.sta[1..].app[0].sendInterval = ${ulInterval}
#**.adHocAp.app[1].sendInterval 	= exponential(${dlInterval=400us}) # Effectively Full Buffer




# Statistics recording - Selectively activating certain statistics to reduce load
**.sta[0].app[1].throughput.statistic-recording 	= true
**.adHocAp.app[0].throughput.statistic-recording 	= true
**.adHocAp.app[2].throughput.statistic-recording 	= true
**.adHocAp.app[1].throughput.statistic-recording 	= false

**.sta[0].wlan[*].mac.corruptedFrameSignal.scalar-recording = true
**.sta[0].wlan[*].mac.collisionsByCorruption.statistic-recording = true
**.collisionSniffer.wlan[*].mac.collisionsByCorruption.statistic-recording = true
**.adHocAp.wlan[1].mac.collisionsByCorruption.statistic-recording = true

# All stations should count, how many Ndf Packets they have sent
**.dcf.numberOfNdfPacketsSent.statistic-recording = true
**.dcf.numNdfSent.statistic-recording = true
**.dcf.rateNdfSent.statistic-recording = true
**.dcf.testNdfSent.statistic-recording = true
**.adHocAp.**.dcf.packetReceivedFromPeer.statistic-recording = true
**.dcf.avgNdfPacketSent.statistic-recording = true



# WIFI CONFIG
# 802.11 ac config
**.bandName = "5 GHz (160 MHz)" 
**.opMode = "ac"
**.wlan[*].radio.antenna.numAntennas = 8
**.bitrate = 693.3Mbps
**.pendingQueue.packetCapacity = 20

# Fragmentation and aggregation
**.mtu = 10000Byte                       		# turn off IP fragmentation
**.fragmentationThreshold = 10000Byte  			# turn off 802.11 fragmentation
**.rtsThreshold = ${rtsThreshold =  12000Byte}		# turn on/off RTS/CTS  , 100Byte, 12000Byte


# FH-settings 
# NOTE: 1us as "no FH-delay" as due to the simulator not modelling errors/processing delays, 
# 	the AP will be implicitly prioritized as it is can access the channel a ToF earlier than 
# 	other stations can, which consequently cancel their contention. This behavior comes up 
# 	because the AP/adHocHost used as an AP substitute is the sole receiver of data. Thus, its
# 	channel access timer starts a little earlier than all the others.
# FH vs. TP 
**.adHocAp.**.fhDelay = ${fhDelay = 1us, 5us, 10us, 18us, 30us, 35us, 40us, 50us, 75us, 100us, 150us, 200us, 250us, 300us}# 

# UL vs. TP 
#**.adHocAp.**.fhDelay = ${fhDelay = 1us, 100 us}

# DL vs. NDF
#**.adHocAp.**.fhDelay = ${fhDelay = 100 us} 




# Increase ACK Timeout Proportionally to FH-Delay
**.ackTimeout 		= (75us+2*${fhDelay})
**.ctsTimeout 		= (75us+2*${fhDelay})
**.blockAckTimeout 	= (75us+2*${fhDelay})


# Toggle between channel Access mechanism
# TP vs. FH & TP vs. UL
**.sta[*].**.fhChannelAccessMechanism = ${channelAccess = "cefi", "standard", "okamoto"} # "consecutiveData"/"CeFi", 

# DL vs. NDF
#**.sta[*].**.fhChannelAccessMechanism = ${channelAccess = "cefi"} 


**.adHocAp.**.fhChannelAccessMechanism = ${channelAccess}

# Setting NAV Extension for stations
**.sta[*].**.dcf.navExtension = ${fhDelay}

# Inform the stations about the APs IP-address
**.wlan[*].mac.dcf.apAddress = "0A-AA-00-00-00-01"

# Configuring the AP
**.adHocAp.**.isFronthaulAffectedAp = true

# Configure probability with which data is transmitted
**.adHocAp.**.alpha = 1 # 0.5



[Config NeighboringNetwork]
network = neighboringNetwork
description = "Setting up the overall settings"
**.arp.typename = "GlobalArp" 



# DEFAULT Number of Stations
**.nSta = ${N= 3} 

# MOBILITY
**.constraintAreaMinX = 0m
**.constraintAreaMinY = 0m
**.constraintAreaMinZ = 0m
**.constraintAreaMaxX = 15m
**.constraintAreaMaxY = 15m
**.constraintAreaMaxZ = 0m


**.sta[*].mobility.typename = "StationaryMobility"
**.sta[*].mobility.initialX = 4m
**.sta[*].mobility.initialY = 3m

**.adHocAp.mobility.typename = "StationaryMobility"
**.adHocAp.mobility.initialX = 3m
**.adHocAp.mobility.initialY = 4m

**.legacySta[*].mobility.typename = "StationaryMobility"
**.legacySta[*].mobility.initialX = 5m
**.legacySta[*].mobility.initialY = 6m

**.legacyAp.mobility.typename = "StationaryMobility"
**.legacyAp.mobility.initialX = 7m
**.legacyAp.mobility.initialY = 6m


**.adHocAp.numApps 	= 2
**.sta[0].numApps 	= 2
**.sta[1..].numApps 	= 1

**.legacyAp.numApps = 2
**.legacySta[0].numApps = 2
**.legacySta[1..].numApps = 1



# Receiver for station transmissions
**.adHocAp.app[0].typename 		= "UdpSink"
**.adHocAp.app[0].localPort 	= 1000

**.legacyAp.app[0].typename 	= "UdpSink"
**.legacyAp.app[0].localPort 	= 1000

# Transmitter to stations
**.adHocAp.app[1].typename 		= "UdpBasicApp"
**.adHocAp.app[1].destPort 		= 1001
**.adHocAp.app[1].destAddresses = "sta[0]"

**.legacyAp.app[1].typename 	= "UdpBasicApp"
**.legacyAp.app[1].destPort 	= 1001
**.legacyAp.app[1].destAddresses= "legacySta[0]"


# Unicast to AP
**.sta[*].app[0].typename 			= "UdpBasicApp"
**.sta[*].app[0].destPort 			= 1000
**.sta[*].app[0].destAddresses 		= "adHocAp" 

**.legacySta[*].app[0].typename 	= "UdpBasicApp"
**.legacySta[*].app[0].destPort 	= 1000
**.legacySta[*].app[0].destAddresses= "legacyAp" 

# Add UDP Sink to the first station
**.sta[0].app[1].typename 			= "UdpSink"
**.sta[0].app[1].localPort 			= 1001

**.legacySta[0].app[1].typename 	= "UdpSink"
**.legacySta[0].app[1].localPort 	= 1001

# Message Length
**.messageLength = ${messageLength = 8000B} 

# SendInterval
# TP vs. UL
#**.sta[0].app[0].sendInterval 	= exponential(${ulInterval = 300us, 2000us, 4000us, 8000us, 16000us, 32000us, 64000us, 256000us, 1024000us})
#**.sta[1..].app[0].sendInterval = exponential(${ulInterval})  
#**.adHocAp.app[1].sendInterval 	= exponential(${dlInterval = 400us}) # 500us


# TP vs. FH
**.sta[0].app[0].sendInterval 	= exponential(${ulInterval = 500 us})
**.sta[1..].app[0].sendInterval = exponential(${ulInterval})  
**.adHocAp.app[1].sendInterval 	= exponential(${dlInterval = 500 us}) # 500us


**.legacySta[*].app[0].sendInterval = exponential(500 us)
**.legacyAp.app[1].sendInterval = exponential(500 us)

# Statistics recording
**.sta[0].app[1].throughput.statistic-recording 		= true
**.adHocAp.app[0].throughput.statistic-recording 		= true
**.adHocAp.app[2].throughput.statistic-recording 		= true
**.adHocAp.app[1].throughput.statistic-recording 		= false

**.legacySta[0].app[1].throughput.statistic-recording 	= true
**.legacyAp.app[0].throughput.statistic-recording 		= true
**.legacyAp.app[2].throughput.statistic-recording 		= true
**.legacyAp.app[1].throughput.statistic-recording 		= false


**.adHocAp.wlan[1].mac.collisionsByCorruption.statistic-recording = true
**.adHocAp.wlan[0].mac.collisionsByCorruption.statistic-recording = true
**.legacyAp.wlan[0].mac.collisionsByCorruption.statistic-recording = true
**.sta[0].wlan[0].mac.collisionsByCorruption.statistic-recording = true
**.legacySta[0].wlan[0].mac.collisionsByCorruption.statistic-recording = true

# All stations should count, how many Ndf Packets they have sent
**.dcf.numberOfNdfPacketsSent.statistic-recording = true
**.dcf.numNdfSent.statistic-recording = true
**.dcf.rateNdfSent.statistic-recording = true
**.dcf.testNdfSent.statistic-recording = true
**.adHocAp.**.dcf.packetReceivedFromPeer.statistic-recording = true
**.dcf.avgNdfPacketSent.statistic-recording = true

**.limitedBroadcast = true #important to send broadcasts


# WIFI-CONFIG
# 802.11 ac config
**.bandName = "5 GHz (160 MHz)" 
**.opMode = "ac"
**.wlan[*].radio.antenna.numAntennas = 8
**.bitrate = 693.3Mbps 
**.pendingQueue.packetCapacity = 20

# turn off IP fragmentation
**.mtu = 10000Byte
# turn off 802.11 fragmentation
**.fragmentationThreshold = 10000Byte  			
# turn on/off RTS/CTS
**.rtsThreshold = ${rtsThreshold =  12000Byte}		



# FH-settings 
# NOTE: 1us as "no FH-delay" as due to the simulator not modelling errors/processing delays, 
# 	the AP will be implicitly prioritized as it is can access the channel a ToF earlier than 
# 	other stations can, which consequently cancel their contention. This behavior comes up 
# 	because the AP/adHocHost used as an AP substitute is the sole receiver of data. Thus, its
# 	channel access timer starts a little earlier than all the others.

# UL vs. TP 
#**.adHocAp.**.fhDelay = ${fhDelay = 1us, 100us}

# FH vs. TP
**.adHocAp.**.fhDelay = ${fhDelay = 1us, 5us, 10us, 18us, 30us, 35us, 40us, 50us, 75us, 100us, 150us, 200us, 250us, 300us}

# NOTE: To mitigate the aforementioned problem of priotization of the AP due to the simulations
#	perfect timings/missing errors, the legacy AP also gets a FH-delay of 1us to simulate
#	imperfections. 

**.legacyAp.**.fhDelay = 1us

**.sta[*].**.ackTimeout = (75us+2*${fhDelay}) #(58us+2*${fhDelay}) 72 before -> Mal sehen, ob es failed 
**.adHocAp.**.ackTimeout = (75us+2*${fhDelay}) #(58us+2*${fhDelay})

**.sta[*].**.ctsTimeout = (75us+2*${fhDelay}) #(58us+2*${fhDelay})
**.adHocAp.**.ctsTimeout = (75us+2*${fhDelay}) #(58us+2*${fhDelay})

**.sta[*].**.blockAckTimeout = (75us+2*${fhDelay}) #(58us+2*${fhDelay})
**.adHocAp.**.blockAckTimeout = (75us+2*${fhDelay}) #(58us+2*${fhDelay})


# Toggle between channel Access mechanism
**.sta[*].**.fhChannelAccessMechanism = ${channelAccess = "standard", "cefi", "okamoto"}
**.adHocAp.**.fhChannelAccessMechanism = ${channelAccess}

# Setting NAV Extension for stations
**.sta[*].**.dcf.navExtension = ${fhDelay}

# Inform the stations about the APs IP-address
**.wlan[*].mac.dcf.apAddress = "0A-AA-00-00-00-01"
#**.adHocAp.**.wlan[*].mac.dcf.apAddress = "0A-AA-00-00-00-01"

# Configuring the AP
**.adHocAp.**.isFronthaulAffectedAp = true

# Configure probability with which data is transmitted
**.adHocAp.**.alpha = 1 # 0.5


[Config GreenField_TCP]
network = adHocNetwork
description = "Setting up the overall settings"
**.arp.typename = "GlobalArp" 



# Number of Stations
**.nSta = ${N = 6 } 


# MOBILITY
**.constraintAreaMinX = 0m
**.constraintAreaMinY = 0m
**.constraintAreaMinZ = 0m
**.constraintAreaMaxX = 15m
**.constraintAreaMaxY = 15m
**.constraintAreaMaxZ = 0m


**.sta[0].mobility.typename = "StationaryMobility"
**.sta[0].mobility.initialX = 4m
**.sta[0].mobility.initialY = 3m

**.adHocAp.mobility.typename = "StationaryMobility"
**.adHocAp.mobility.initialX = 3m
**.adHocAp.mobility.initialY = 4m



# APPLICATION
**adHocAp.numApps 	= 1
**sta[0].numApps 	= 1
**sta[1..].numApps 	= 1


# TCP CLIENT
**.sta[*].app[0].typename = "TcpBasicClientApp" 
**.sta[*].app[0].localPort = -1
**.sta[*].app[0].connectAddress = "adHocAp"
**.sta[*].app[0].connectPort = 1001
**.sta[*].app[0].startTime = 0s
**.sta[*].app[0].stopTime = -1s
**.sta[*].app[0].numRequestsPerSession = 1
**.sta[*].app[0].replyLength = 1GiB
**.sta[*].app[0].idleInterval = 60s
**.sta[*].app[0].thinkTime = 60s


# TCP SERVER
**.adHocAp.app[0].typename = "TcpGenericServerApp"  
**.adHocAp.app[0].localPort = 1001
**.adHocAp.app[0].replyDelay = 0s


## tcp settings
**.tcp.typename = "Tcp"
**.tcp.advertisedWindow = 65535
**.tcp.delayedAcksEnabled = false
**.tcp.nagleEnabled = true
**.tcp.limitedTransmitEnabled = false
**.tcp.increasedIWEnabled = false
**.tcp.sackSupport = true
**.tcp.windowScalingSupport = false
**.tcp.timestampSupport = false
**.tcp.mss = ${messageLength = 8000}
**.tcp.tcpAlgorithmClass = "TcpReno"


**.sta[0].app[0].placeholder 	= ${ulInterval = 60000000 us}
**.sta[1..].app[0].placeholder  = ${ulInterval}
**.adHocAp.app[1].placeholder 	= exponential(${dlInterval=400us})


# Statistics recording
**.sta[*].app[*].packetReceived.statistic-recording = true
**.sta[*].app[*].packetSent.statistic-recording = true
**.adHocAp.app[*].packetReceived.statistic-recording = true
**.adHocAp.app[*].packetSent.statistic-recording = true


**.sta[*].app[0].throughput.statistic-recording 	= true
**.adHocAp.app[0].throughput.statistic-recording 	= true

**.sta[0].wlan[*].mac.corruptedFrameSignal.scalar-recording = true
**.sta[0].wlan[*].mac.collisionsByCorruption.statistic-recording = true
**.collisionSniffer.wlan[*].mac.collisionsByCorruption.statistic-recording = true
**.adHocAp.wlan[1].mac.collisionsByCorruption.statistic-recording = true

# All stations should count, how many Ndf Packets they have sent
**.dcf.numberOfNdfPacketsSent.statistic-recording = true
**.dcf.numNdfSent.statistic-recording = true
**.dcf.rateNdfSent.statistic-recording = true
**.dcf.testNdfSent.statistic-recording = true
**.adHocAp.**.dcf.packetReceivedFromPeer.statistic-recording = true
**.dcf.avgNdfPacketSent.statistic-recording = true


**.limitedBroadcast = true #important to send broadcasts

# WIFI CONFIG

# 802.11 ac config
**.bandName = "5 GHz (160 MHz)"
**.opMode = "ac"
**.wlan[*].radio.antenna.numAntennas = 8
**.bitrate = 693.3Mbps # 867Mbps
**.pendingQueue.packetCapacity = 20

# Fragmentation and aggregation
# turn off IP fragmentation
**.mtu = 10000Byte
# turn off 802.11 fragmentation
**.fragmentationThreshold = 10000Byte
# turn on/off RTS/CTS 
**.rtsThreshold = ${rtsThreshold =  12000Byte}


# FH-settings 
# NOTE: 1us as "no FH-delay" as due to the simulator not modelling errors/processing delays, 
# 	the AP will be implicitly prioritized as it is can access the channel a ToF earlier than 
# 	other stations can, which consequently cancel their contention. This behavior comes up 
# 	because the AP/adHocHost used as an AP substitute is the sole receiver of data. Thus, its
# 	channel access timer starts a little earlier than all the others.
# DL vs. NDF
**.adHocAp.**.fhDelay = ${fhDelay = 1 us, 100 us} #

**.ackTimeout 		= (75us+2*${fhDelay}) #
**.ctsTimeout 		= (75us+2*${fhDelay})
**.blockAckTimeout 	= (75us+2*${fhDelay})


# Toggle between channel Access mechanism
# TP vs. NDF
**.sta[*].**.fhChannelAccessMechanism = ${channelAccess ="cefi","okamoto", "standard" } # , "cefi", 

**.adHocAp.**.fhChannelAccessMechanism = ${channelAccess}

# Setting NAV Extension for stations
**.sta[*].**.dcf.navExtension = ${fhDelay}

# Inform the stations about the APs IP-address
**.wlan[*].mac.dcf.apAddress = "0A-AA-00-00-00-01"

# Configuring the AP 
**.adHocAp.**.isFronthaulAffectedAp = true

# Configure probability with which data is transmitted
**.adHocAp.**.alpha = 1 # 0.5